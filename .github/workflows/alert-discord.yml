name: Reusable Discord Alert

on:
  workflow_call:
    inputs:
      message_body:
        description: "The main message content to send. Supports markdown and newlines."
        required: true
        type: string
      user_keys_to_ping:
        description: "Comma-separated list of user keys (e.g., GitHub usernames) to ping. These keys will be looked up in the DISCORD_USER_MAP secret to find Discord User IDs."
        required: false
        type: string
        default: ""
      artifact_paths:
        description: "Comma-separated list of paths (relative to GITHUB_WORKSPACE) to image/video artifacts to upload (e.g., 'reports/image.png,output/video.mp4')."
        required: false
        type: string
        default: ""
      should_notify:
        description: "Boolean flag indicating whether notification should be sent."
        required: false
        type: string
        default: "true"
    secrets:
      DISCORD_WEBHOOK_URL:
        description: "The Discord Webhook URL."
        required: true
      DISCORD_USER_MAP:
        description: 'JSON string mapping user keys to Discord User IDs. E.g., ''{"gh_user":"discord_id","another_user":"id"}'''
        required: false

jobs:
  send-discord-alert:
    runs-on: ubuntu-latest
    name: Send Alert to Discord
    steps:
      # This step assumes artifacts are already in the workspace (e.g., from a previous job or checked out code).
      # If artifacts were created by actions/upload-artifact, they would need to be downloaded first by the calling workflow
      # or this workflow would need a download step if it were to receive artifact names instead of paths.

      - name: Check webhook availability
        id: check-webhook
        run: |
          # Simple check for webhook URL before attempting to send
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            echo "Discord webhook URL is set and will be used."
            echo "webhook_present=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::DISCORD_WEBHOOK_URL is not set or is empty. Notification will be skipped. Please ensure the secret is configured in repository/organization settings and correctly passed to this workflow."
            echo "webhook_present=false" >> $GITHUB_OUTPUT
          fi

      - name: Send Discord Notification
        if: inputs.should_notify == 'true' && steps.check-webhook.outputs.webhook_present == 'true'
        env:
          # Secrets and inputs are passed as environment variables for safer handling in script
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          MESSAGE_BODY_INPUT: ${{ inputs.message_body }}
          USER_KEYS_TO_PING_INPUT: ${{ inputs.user_keys_to_ping }}
          DISCORD_USER_MAP_SECRET: ${{ secrets.DISCORD_USER_MAP }}
          ARTIFACT_PATHS_INPUT: ${{ inputs.artifact_paths }}
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          # set -x # Uncomment for detailed command printing during debugging

          if [ -z "$WEBHOOK_URL" ]; then
            echo "::error::DISCORD_WEBHOOK_URL secret is not set or empty."
            exit 1
          fi

          # Check for jq availability (required for parsing DISCORD_USER_MAP)
          if ! command -v jq &> /dev/null; then
              echo "::warning::jq command-line JSON processor is not available. Pings based on DISCORD_USER_MAP will not work. Please install jq on the runner."
              # Fallback or exit if jq is critical and not found. For now, will allow message sending without pings if map is used.
          fi

          # Process message_body to convert literal '\\n' (backslash-n) to actual newlines
          # This helps if the input message_body contains \\n instead of actual newlines.
          PROCESSED_MESSAGE_BODY=$(echo "$MESSAGE_BODY_INPUT" | sed 's/\\\\n/\\n/g')

          # 1. Construct user pings prefix based on DISCORD_USER_MAP and USER_KEYS_TO_PING_INPUT
          PINGS_PREFIX=""
          if [ -n "$USER_KEYS_TO_PING_INPUT" ] && [ -n "$DISCORD_USER_MAP_SECRET" ] && command -v jq &> /dev/null; then
            if ! echo "$DISCORD_USER_MAP_SECRET" | jq empty > /dev/null 2>&1; then
              echo "::warning::DISCORD_USER_MAP secret is not valid JSON. Skipping pings based on user keys."
            else
              FORMATTED_USER_KEYS=$(echo "$USER_KEYS_TO_PING_INPUT" | sed 's/,/ /g')
              for user_key in $FORMATTED_USER_KEYS; do
                trimmed_user_key=$(echo "$user_key" | xargs) # Trim whitespace
                if [ -n "$trimmed_user_key" ]; then
                  # Safely extract Discord ID using jq with --arg
                  discord_user_id=$(echo "$DISCORD_USER_MAP_SECRET" | jq -r --arg K "$trimmed_user_key" '.[$K]')
                  
                  if [ -n "$discord_user_id" ] && [ "$discord_user_id" != "null" ]; then
                    PINGS_PREFIX="${PINGS_PREFIX}<@${discord_user_id}> "
                  else
                    echo "::warning::User key '$trimmed_user_key' not found in DISCORD_USER_MAP or has a null value. Skipping ping for this user."
                  fi
                fi
              done
            fi
          elif [ -n "$USER_KEYS_TO_PING_INPUT" ] && [ -z "$DISCORD_USER_MAP_SECRET" ]; then
            echo "::warning::'user_keys_to_ping' were provided, but the 'DISCORD_USER_MAP' secret is missing. Cannot process pings."
          elif [ -n "$USER_KEYS_TO_PING_INPUT" ] && ! command -v jq &> /dev/null; then
            echo "::warning::'user_keys_to_ping' were provided, but 'jq' is not available to parse 'DISCORD_USER_MAP'. Pings will be skipped."
          fi

          # 2. Prepare final message content for JSON
          # Escape only backslashes and double quotes. Newlines in MESSAGE_BODY_INPUT
          # will be preserved as actual newlines in the JSON content, which Discord handles.
          CONTENT_TO_SEND="${PINGS_PREFIX}${PROCESSED_MESSAGE_BODY}"
          ESCAPED_JSON_CONTENT=$(echo "$CONTENT_TO_SEND" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')

          # 3. Construct the core JSON payload part for the 'payload_json' field or -d
          JSON_PAYLOAD_PART="{\"content\": \"$ESCAPED_JSON_CONTENT\"}"

          # 4. Prepare curl arguments array
          CURL_ARGS=("-sS" "-X" "POST") # -sS for silent operation but show errors

          # 5. Check for artifacts and build form data if needed
          VALID_ARTIFACT_FILES=()
          if [ -n "$ARTIFACT_PATHS_INPUT" ]; then
            IFS=',' read -ra ALL_ARTIFACT_PATHS_ARRAY <<< "$ARTIFACT_PATHS_INPUT"
            for artifact_path_item in "${ALL_ARTIFACT_PATHS_ARRAY[@]}"; do
              trimmed_path_item=$(echo "$artifact_path_item" | xargs) # Trim whitespace from path
              if [ -f "$trimmed_path_item" ]; then
                VALID_ARTIFACT_FILES+=("$trimmed_path_item")
              else
                echo "::warning::Artifact file not found or is not a regular file, skipping: '$trimmed_path_item'"
              fi
            done
          fi

          if [ ${#VALID_ARTIFACT_FILES[@]} -gt 0 ]; then
            echo "::debug::Preparing multipart/form-data request with ${#VALID_ARTIFACT_FILES[@]} artifact(s)."
            # For multipart/form-data, the JSON payload goes into a field named 'payload_json'
            CURL_ARGS+=("-F" "payload_json=$JSON_PAYLOAD_PART")
            FILE_INDEX=0
            for valid_file_path_item in "${VALID_ARTIFACT_FILES[@]}"; do
              FILE_INDEX=$((FILE_INDEX + 1))
              CURL_ARGS+=("-F" "file${FILE_INDEX}=@${valid_file_path_item}")
              echo "::debug::Attaching artifact: '$valid_file_path_item' as file${FILE_INDEX}"
            done
          else
            echo "::debug::Preparing application/json request (no valid artifacts)."
            # For simple message without files, use Content-Type: application/json and -d for data
            CURL_ARGS+=("-H" "Content-Type: application/json")
            CURL_ARGS+=("-d" "$JSON_PAYLOAD_PART")
          fi

          # Add the Webhook URL as the last argument
          CURL_ARGS+=("$WEBHOOK_URL")

          # 6. Execute curl and check HTTP response code
          echo "::debug::Sending notification to Discord..."
          # The -w flag writes out the HTTP status code, -o /dev/null discards the response body from stdout
          HTTP_RESPONSE_CODE=$(curl --write-out "%{http_code}" -o /dev/null "${CURL_ARGS[@]}")

          if [ "$HTTP_RESPONSE_CODE" -ge 200 ] && [ "$HTTP_RESPONSE_CODE" -lt 300 ]; then
            echo "Notification sent successfully to Discord (HTTP $HTTP_RESPONSE_CODE)."
          else
            echo "::error::Failed to send Discord notification. HTTP Status Code: $HTTP_RESPONSE_CODE."
            # For more detailed error, you might need to capture curl's stderr or the response body
            # Example: response_body=$(curl --write-out "%{http_code}" "${CURL_ARGS[@]}") etc.
            exit 1
          fi
